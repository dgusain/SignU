import mujoco_py
import os
import time
import numpy as np
from scipy.optimize import lsq_linear

# -------------------- Load the MuJoCo Model --------------------
# Load the model from the specified XML path
xml_path = os.path.expanduser('/home/ducky/Downloads/Bot_hand/bot_hand.xml')
model = mujoco_py.load_model_from_path(xml_path)
sim = mujoco_py.MjSim(model)
viewer = mujoco_py.MjViewer(sim)

# -------------------- Define Actuator Mappings --------------------
# Mapping of actuators to their respective IDs for different fingers and wrist
tendon_actuators = {
    "Wrist": [sim.model.actuator_name2id(name) for name in [
        "WRJ1r_motor", "WRJ1l_motor", "WRJ0u_motor", "WRJ0d_motor"]],
    "ForeFinger": [sim.model.actuator_name2id(name) for name in [
        "FFJ3r_motor", "FFJ3l_motor", "FFJ2u_motor", "FFJ2d_motor", "FFJ1u_motor", "FFJ1d_motor"]],
    "MiddleFinger": [sim.model.actuator_name2id(name) for name in [
        "MFJ3r_motor", "MFJ3l_motor", "MFJ2u_motor", "MFJ2d_motor", "MFJ1u_motor", "MFJ1d_motor"]],
    "RingFinger": [sim.model.actuator_name2id(name) for name in [
        "RFJ3r_motor", "RFJ3l_motor", "RFJ2u_motor", "RFJ2d_motor", "RFJ1u_motor", "RFJ1d_motor"]],
    "LittleFinger": [sim.model.actuator_name2id(name) for name in [
        "LFJ4u_motor", "LFJ4d_motor", "LFJ3r_motor", "LFJ3l_motor", "LFJ2u_motor", "LFJ2d_motor", "LFJ1u_motor", "LFJ1d_motor"]],
    "Thumb": [sim.model.actuator_name2id(name) for name in [
        "THJ4a_motor", "THJ4c_motor", "THJ3u_motor", "THJ3d_motor", "THJ2u_motor", "THJ2d_motor", 
        "THJ1r_motor", "THJ1l_motor", "THJ0r_motor", "THJ0l_motor"]],
}

# -------------------- Define Actuator Coefficients --------------------
# Coefficients mapping each actuator to its controlled joints and their coefficients
actuator_coefficients = {
    "WRJ1r_motor": {"WristJoint1": 0.018},
    "WRJ1l_motor": {"WristJoint1": -0.018},
    "WRJ0u_motor": {"WristJoint0": 0.018},
    "WRJ0d_motor": {"WristJoint0": -0.018},
    "FFJ3r_motor": {"ForeFingerJoint3": 0.010},
    "FFJ3l_motor": {"ForeFingerJoint3": -0.010},
    "FFJ2u_motor": {"ForeFingerJoint2": 0.010},
    "FFJ2d_motor": {"ForeFingerJoint2": -0.010},
    "FFJ1u_motor": {"ForeFingerJoint0": 0.00705, "ForeFingerJoint1": 0.00805},
    "FFJ1d_motor": {"ForeFingerJoint0": -0.00705, "ForeFingerJoint1": -0.00805},
    "MFJ3r_motor": {"MiddleFingerJoint3": 0.010},
    "MFJ3l_motor": {"MiddleFingerJoint3": -0.010},
    "MFJ2u_motor": {"MiddleFingerJoint2": 0.010},
    "MFJ2d_motor": {"MiddleFingerJoint2": -0.010},
    "MFJ1u_motor": {"MiddleFingerJoint0": 0.00705, "MiddleFingerJoint1": 0.00805},
    "MFJ1d_motor": {"MiddleFingerJoint0": -0.00705, "MiddleFingerJoint1": -0.00805},
    "RFJ3r_motor": {"RingFingerJoint3": 0.010},
    "RFJ3l_motor": {"RingFingerJoint3": -0.010},
    "RFJ2u_motor": {"RingFingerJoint2": 0.010},
    "RFJ2d_motor": {"RingFingerJoint2": -0.010},
    "RFJ1u_motor": {"RingFingerJoint0": 0.00705, "RingFingerJoint1": 0.00805},
    "RFJ1d_motor": {"RingFingerJoint0": -0.00705, "RingFingerJoint1": -0.00805},
    "LFJ4u_motor": {"LittleFingerJoint4": 0.010},
    "LFJ4d_motor": {"LittleFingerJoint4": -0.010},
    "LFJ3r_motor": {"LittleFingerJoint3": 0.010},
    "LFJ3l_motor": {"LittleFingerJoint3": -0.010},
    "LFJ2u_motor": {"LittleFingerJoint2": 0.010},
    "LFJ2d_motor": {"LittleFingerJoint2": -0.010},
    "LFJ1u_motor": {"LittleFingerJoint0": 0.00705, "LittleFingerJoint1": 0.00805},
    "LFJ1d_motor": {"LittleFingerJoint0": -0.00705, "LittleFingerJoint1": -0.00805},
    "THJ4a_motor": {"ThumbJoint4": 0.01636},
    "THJ4c_motor": {"ThumbJoint4": -0.01636},
    "THJ3u_motor": {"ThumbJoint3": 0.010},
    "THJ3d_motor": {"ThumbJoint3": -0.010},
    "THJ2u_motor": {"ThumbJoint2": 0.011},
    "THJ2d_motor": {"ThumbJoint2": -0.011},
    "THJ1r_motor": {"ThumbJoint1": 0.011},
    "THJ1l_motor": {"ThumbJoint1": -0.011},
    "THJ0r_motor": {"ThumbJoint0": 0.009},
    "THJ0l_motor": {"ThumbJoint0": -0.009},
}

# -------------------- Helper Mappings --------------------
# Create a reverse mapping from actuator ID to actuator name
actuator_id_to_name = {}
for i, name in enumerate(sim.model.actuator_names):
    if isinstance(name, bytes):
        actuator_id_to_name[i] = name.decode('utf-8')
    else:
        actuator_id_to_name[i] = name

# -------------------- Torque Calculation Function --------------------
def calculate_total_torque(tendon_ctrls, actuator_coeffs):
    """
    Calculate the total torque generated by the current tendon controls.

    Parameters:
    - tendon_ctrls (dict): Dictionary mapping actuator IDs to control inputs.
    - actuator_coeffs (dict): Dictionary mapping actuator names to joint coefficients.

    Returns:
    - float: Total torque acting on the hand.
    """
    total_torque = 0.0
    for act_id, ctrl in tendon_ctrls.items():
        act_name = actuator_id_to_name.get(act_id, None)
        if act_name is None:
            print(f"Warning: Actuator ID {act_id} not found in actuator_id_to_name mapping.")
            continue  # Skip if actuator name is not found
        joint_coeffs = actuator_coeffs.get(act_name, {})
        for joint, coef in joint_coeffs.items():
            torque = ctrl * coef
            total_torque += torque
    return total_torque

# -------------------- Wrist Control Computation Function --------------------
def compute_wrist_controls(counter_torque, wrist_actuators, actuator_coeffs):
    """
    Compute the necessary wrist actuator controls to counterbalance the total torque.

    Parameters:
    - counter_torque (float): The torque that needs to be counteracted.
    - wrist_actuators (list): List of wrist actuator IDs.
    - actuator_coeffs (dict): Dictionary mapping actuator names to joint coefficients.

    Returns:
    - dict: Dictionary mapping wrist actuator IDs to their computed control inputs.
    """
    # Collect coefficients for wrist actuators
    coeffs = []
    for wrist_act in wrist_actuators:
        act_name = actuator_id_to_name.get(wrist_act, None)
        if act_name is None:
            print(f"Warning: Wrist actuator ID {wrist_act} not found in actuator_id_to_name mapping.")
            coeffs.append(0.0)
            continue
        joint_coeffs = actuator_coeffs.get(act_name, {})
        # Sum coefficients if multiple joints are controlled
        total_coef = sum(joint_coeffs.values())
        coeffs.append(total_coef)
    
    coeffs = np.array(coeffs)  # Shape: (4,)
    
    # Setup the linear equation: A * x = b
    A = coeffs.reshape(1, -1)  # Shape: (1,4)
    b = np.array([counter_torque])  # Shape: (1,)
    
    # Define bounds for control inputs: [-1.0, 0.0]
    lower_bounds = np.full(len(wrist_actuators), -1.0)
    upper_bounds = np.zeros(len(wrist_actuators))
    
    # Use least squares optimization to find control inputs
    res = lsq_linear(A, b, bounds=(lower_bounds, upper_bounds))
    
    if res.success:
        wrist_controls = res.x
    else:
        print("Warning: Wrist control optimization did not converge. Using zero controls.")
        wrist_controls = np.zeros(len(wrist_actuators))
    
    # Create a dictionary mapping wrist actuator IDs to their control inputs
    wrist_ctrl_dict = {}
    for i, act_id in enumerate(wrist_actuators):
        # Ensure control inputs are within [-1.0, 0.0]
        ctrl = np.clip(wrist_controls[i], -1.0, 0.0)
        wrist_ctrl_dict[act_id] = ctrl
    
    return wrist_ctrl_dict

# -------------------- Control Function --------------------
def set_tendon_controls(tendon_ctrls, actuator_coeffs, steps=200, delay=0.02):
    """
    Set the tendon controls for non-wrist actuators, calculate the resulting torque,
    compute the required wrist controls to counterbalance, and apply them.

    Parameters:
    - tendon_ctrls (dict): Dictionary mapping actuator IDs to desired control inputs.
    - actuator_coeffs (dict): Dictionary mapping actuator names to joint coefficients.
    - steps (int): Number of interpolation steps for smooth transitions.
    - delay (float): Delay between each simulation step (in seconds).
    """
    # Separate wrist and non-wrist actuators
    wrist_actuators_list = tendon_actuators["Wrist"]
    non_wrist_actuators = [
        act for category, acts in tendon_actuators.items() if category != "Wrist" for act in acts
    ]
    
    # Extract non-wrist controls
    non_wrist_ctrls = {
        act: ctrl for act, ctrl in tendon_ctrls.items() if act in non_wrist_actuators
    }
    
    # Smoothly set non-wrist actuator controls
    for i in range(steps):
        for act, target_ctrl in non_wrist_ctrls.items():
            current_ctrl = sim.data.ctrl[act]
            # Linear interpolation towards target control
            new_ctrl = current_ctrl + (target_ctrl - current_ctrl) * (i / steps)
            # Clamp the control within actuator's range
            ctrl_min, ctrl_max = sim.model.actuator_ctrlrange[act]
            new_ctrl = max(min(new_ctrl, ctrl_max), ctrl_min)
            sim.data.ctrl[act] = new_ctrl
        sim.step()
        viewer.render()
        time.sleep(delay)
    
    # Calculate the total torque from non-wrist actuators
    total_torque = calculate_total_torque(non_wrist_ctrls, actuator_coefficients)
    print(f"Total Torque from Non-Wrist Actuators: {total_torque:.5f} Nm")
    
    # Determine the required counter-torque
    counter_torque = -total_torque
    print(f"Required Counter-Torque: {counter_torque:.5f} Nm")
    
    # Compute wrist actuator controls to counterbalance the torque
    wrist_ctrls = compute_wrist_controls(counter_torque, wrist_actuators_list, actuator_coefficients)
    print(wrist_ctrls)
    # Smoothly set wrist actuator controls
    for i in range(steps):
        for act, target_ctrl in wrist_ctrls.items():
            current_ctrl = sim.data.ctrl[act]
            # Linear interpolation towards target control
            new_ctrl = current_ctrl + (target_ctrl - current_ctrl) * (i / steps)
            # Ensure control inputs are within [-1.0, 0.0]
            new_ctrl = np.clip(new_ctrl, -1.0, 0.0)
            sim.data.ctrl[act] = new_ctrl
        sim.step()
        viewer.render()
        time.sleep(delay)

# -------------------- Define Closed Fist Positions --------------------
# Define the desired control inputs for a closed fist
asl_closed_fist_positions = {
    # Wrist
    tendon_actuators["Wrist"][0]: 0.0,  # WRJ1r_motor (pull)
    tendon_actuators["Wrist"][1]: 0.0,  # WRJ1l_motor (release)
    tendon_actuators["Wrist"][2]: 0.0,  # WRJ0u_motor (pull)
    tendon_actuators["Wrist"][3]: 0.0,  # WRJ0d_motor (release)

    # ForeFinger
    tendon_actuators["ForeFinger"][0]: 0.0,  # FFJ3r_motor (pull)
    tendon_actuators["ForeFinger"][1]: 0.0,  # FFJ3l_motor (release)
    tendon_actuators["ForeFinger"][2]: 0.0,  # FFJ2u_motor (pull)
    tendon_actuators["ForeFinger"][3]: -1.0,  # FFJ2d_motor (release)
    tendon_actuators["ForeFinger"][4]: 0.0,  # FFJ1u_motor (pull)
    tendon_actuators["ForeFinger"][5]: -1.0,  # FFJ1d_motor (release)

    # MiddleFinger
    tendon_actuators["MiddleFinger"][0]: 0.0,  # MFJ3r_motor (pull)
    tendon_actuators["MiddleFinger"][1]: 0.0,  # MFJ3l_motor (release)
    tendon_actuators["MiddleFinger"][2]: 0.0,  # MFJ2u_motor (pull)
    tendon_actuators["MiddleFinger"][3]: -1.0,  # MFJ2d_motor (release)
    tendon_actuators["MiddleFinger"][4]: 0.0,  # MFJ1u_motor (pull)
    tendon_actuators["MiddleFinger"][5]: -1.0,  # MFJ1d_motor (release)

    # RingFinger
    tendon_actuators["RingFinger"][0]: 0.0,  # RFJ3r_motor (pull)
    tendon_actuators["RingFinger"][1]: 0.0,  # RFJ3l_motor (release)
    tendon_actuators["RingFinger"][2]: 0.0,  # RFJ2u_motor (pull)
    tendon_actuators["RingFinger"][3]: -1.0,  # RFJ2d_motor (release)
    tendon_actuators["RingFinger"][4]: 0.0,  # RFJ1u_motor (pull)
    tendon_actuators["RingFinger"][5]: -1.0,  # RFJ1d_motor (release)

    # LittleFinger
    tendon_actuators["LittleFinger"][0]: 0.0,  # LFJ4u_motor (pull)
    tendon_actuators["LittleFinger"][1]: 0.0,  # LFJ4d_motor (release)
    tendon_actuators["LittleFinger"][2]: 0.0,  # LFJ3r_motor (pull)
    tendon_actuators["LittleFinger"][3]: 0.0,  # LFJ3l_motor (release)
    tendon_actuators["LittleFinger"][4]: 0.0,  # LFJ2u_motor (pull)
    tendon_actuators["LittleFinger"][5]: -1.0,  # LFJ2d_motor (release)
    tendon_actuators["LittleFinger"][6]: 0.0,  # LFJ1u_motor (pull)
    tendon_actuators["LittleFinger"][7]: -1.0,  # LFJ1d_motor (release)

    # Thumb
    tendon_actuators["Thumb"][0]: 0.0,  # THJ4a_motor (pull)
    tendon_actuators["Thumb"][1]: 0.0,  # THJ4c_motor (release)
    tendon_actuators["Thumb"][2]: 0.0,  # THJ3u_motor (pull)
    tendon_actuators["Thumb"][3]: 0.0,  # THJ3d_motor (release)
    tendon_actuators["Thumb"][4]: 0.0,  # THJ2u_motor (pull)
    tendon_actuators["Thumb"][5]: 0.0,  # THJ2d_motor (release)
    tendon_actuators["Thumb"][6]: 0.0,  # THJ1r_motor (pull)
    tendon_actuators["Thumb"][7]: 0.0,  # THJ1l_motor (release)
    tendon_actuators["Thumb"][8]: 0.0,  # THJ0r_motor (pull)
    tendon_actuators["Thumb"][9]: 0.0,  # THJ0l_motor (release)
}

asl_revert = {
    **{actuator: 0.0 for t in ["ForeFinger", "MiddleFinger", "RingFinger", "LittleFinger","Thumb","Wrist"] for actuator in tendon_actuators[t]},
    tendon_actuators["Wrist"][0]: 0.0,  # WRJ1r_motor (pull)
    tendon_actuators["Wrist"][1]: 0.0,  # WRJ1l_motor (release)
    tendon_actuators["Wrist"][2]: 0.0,  # WRJ0u_motor (pull)   
    tendon_actuators["Wrist"][3]: 0.0,  # WRJ0d_motor (release)
    
    tendon_actuators["MiddleFinger"][2]: -1.0,  # FFJ2u_motor (pull)
    tendon_actuators["MiddleFinger"][4]: -1.0,  # MFJ1u_motor (pull)
    tendon_actuators["ForeFinger"][2]: -1.0,  # FFJ2d_motor (release)
    tendon_actuators["ForeFinger"][4]: -1.0,  # FFJ1d_motor (release)
    tendon_actuators["RingFinger"][2]: -1.0,  # RFJ2d_motor (release)
    tendon_actuators["RingFinger"][4]: -1.0,  # RFJ1d_motor (release)
    tendon_actuators["LittleFinger"][4]: -1.0,  # LFJ2d_motor (release)
    tendon_actuators["LittleFinger"][6]: -1.0,  # LFJ1d_motor (release)
}

# -------------------- Define Wrist Adjustments --------------------
# Initially set wrist controls to neutral
wrist_adjust = {
    # Wrist
    tendon_actuators["Wrist"][0]: 0.0,  # WRJ1r_motor (pull)
    tendon_actuators["Wrist"][1]: 0.0,  # WRJ1l_motor (release)
    tendon_actuators["Wrist"][2]: 0.0,  # WRJ0u_motor (pull)
    tendon_actuators["Wrist"][3]: 0.0,  # WRJ0d_motor (release)
}

# -------------------- Main Execution Loop --------------------
# Number of times to set the closed fist position
num_iterations = 2

for i in range(num_iterations):
    print(f"--- Iteration {i+1} ---")
    # Set the hand to the closed fist position
    set_tendon_controls(asl_closed_fist_positions, actuator_coefficients)
    time.sleep(0.02)  # Short pause between iterations
    # Optionally, reset or adjust wrist actuators
    set_tendon_controls(asl_revert, actuator_coefficients)
    time.sleep(0.02)

# Keep the simulation running to view the result
while True:
    viewer.render()
    time.sleep(0.01)

